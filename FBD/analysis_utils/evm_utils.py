#!/usr/local/bin/python3

# Common utility function to handle evm opcode  
#
# Author: Dr. Wang 
import sys, os

# The definition of instruction
class EVMInstruction():

    def __init__(self, name, operand, address, tag_id, annotation, bin_range, src_range):
        
        # ==== Available in both solidityAnalyzer and binaryAnalyzer ====
        #
        #   Instruction name, such as PUSH2, POP, JUMP, INVALID
        self.name = name
        #
        #   The operand of the PUSHxx instruction. The type is int
        self.operand = operand      
        #
        #   The pc address of the instruction with respect to the code start (can be deploy or runtime). The type is int
        self.address = address      
        #
        #   For PUSH, tag_id is set as an int if the instruction pushes an address for latter use of JUMP/JUMPI, otherwise None. 
        #   The special id 0 represents the error tag, not a real tag id.
        #   For JUMPDEST, the tag_id is always set as a non-zero integer.
        self.tag_id = tag_id
        # 
        #   For PUSH, can be "#$", "$", which represent constant that must be filled
        #   For JUMP, can be "[in]" (function call), "[out]" (function return), 
        #   For JUMP/JUMPI, can be "[error]" (jump to invalid address to implement INVALID instruction)
        self.annotation = annotation
        
        
        # ==== These are only available in solidityAnalyzer ====
        #
        #   A tuple that demarcates this instruction (including the operand) in the .bin file generated by "solc --bin"
        #   The type is (int, int)
        self.bin_range = bin_range
        #
        #   A tuple that demarcates the character position of the statement that this instruction belong to in the *.sol file.
        #   The type is (int, int)
        self.src_range = src_range
    
    def __repr__(self):
        return self.__str__()

    def __str__(self):

        tag_str = ""
        if self.tag_id!=None:
            tag_str = " tag:"+str(self.tag_id)
        
        operand_str = ""
        if self.name.startswith("PUSH"):
            if self.operand!=None:
                operand_str = " "+str(self.operand)
        
        annotation_str = ""
        if self.annotation!=None:
            annotation_str = " "+str(self.annotation)
        
        return "[%s %s pc:%s %s]" % (self.name+operand_str, annotation_str, str(self.address), tag_str)
        

# Generate regular function signature hash
def canon_signature_hash(tag_hash):
    assert (tag_hash.startswith("0x"))
    diff = 10 - len(tag_hash)
    stub = ""
    for k in range(0, diff):  # @UnusedVariable
        stub += "0"
    tag_hash = tag_hash[2:]
    tag_hash = "0x" + stub + tag_hash
    return tag_hash


# Remove stub in evm bin string
def replace_evm_stub(bin):
    
    while bin.find("_")!=-1:
        idx = bin.find("_")
        #                     "__code.sol:SafeMath_____________________"
        bin = bin[:idx]+"0000000000000000000000000000000000000000"+bin[idx+40:]
    
    while bin.rfind("//")!=-1:
        idx = bin.find("//")
        bin=bin[:idx]
    
    bin=bin.strip()
    return bin


mask_set = set([
    int("ffff", 16), \
    int("ffffffff", 16), \
    int("ffffffffffff", 16), \
    int("ffffffffffffffff", 16),\
    int("ffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16),\
    int("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16)])


# Get the set of block ids in the function selector
def get_selector_blocks(runtime_instructions, basic_blocks):
    
    selector_blocks = set()
    
    # Map each instruction to the basic block it belongs to.
    instruction_index_to_block_id = {}
    for basic_block_id in range(0, len(basic_blocks)):
        basic_block = basic_blocks[basic_block_id]
        for idx in range(basic_block[0], basic_block[1]+1):
            instruction_index_to_block_id[idx] = basic_block_id
    
    # Search the function selector to find all external tags and the fallback tag
    for i in range(0, len(runtime_instructions)):
        if runtime_instructions[i].name == "JUMPDEST":
            break
        selector_blocks.add(instruction_index_to_block_id[i])
        
    return selector_blocks
    



